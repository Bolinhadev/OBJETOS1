<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detecção de Objetos Otimizada com COCO-SSD</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            overflow: hidden;
        }
        #container {
            position: relative;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" width="640" height="480" autoplay muted></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="loading">Carregando modelo...</div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingElement = document.getElementById('loading');

        let model;
        let detectionHistory = {};
        const historyLength = 5;
        const confidenceThreshold = 0.5;

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        async function loadModel() {
            model = await cocoSsd.load();
            loadingElement.style.display = 'none';
        }

        function updateDetectionHistory(detections) {
            detections.forEach(detection => {
                if (!detectionHistory[detection.class]) {
                    detectionHistory[detection.class] = [];
                }
                detectionHistory[detection.class].push(detection);
                if (detectionHistory[detection.class].length > historyLength) {
                    detectionHistory[detection.class].shift();
                }
            });

            // Remove classes that are no longer detected
            Object.keys(detectionHistory).forEach(className => {
                if (!detections.some(d => d.class === className)) {
                    detectionHistory[className].shift();
                    if (detectionHistory[className].length === 0) {
                        delete detectionHistory[className];
                    }
                }
            });
        }

        function getSmoothedDetection(className) {
            const history = detectionHistory[className];
            if (!history || history.length === 0) return null;

            const recentDetections = history.filter(d => d.score >= confidenceThreshold);
            if (recentDetections.length === 0) return null;

            const avgDetection = recentDetections.reduce((acc, det) => {
                acc.score += det.score;
                acc.bbox[0] += det.bbox[0];
                acc.bbox[1] += det.bbox[1];
                acc.bbox[2] += det.bbox[2];
                acc.bbox[3] += det.bbox[3];
                return acc;
            }, { score: 0, bbox: [0, 0, 0, 0] });

            const count = recentDetections.length;
            avgDetection.score /= count;
            avgDetection.bbox = avgDetection.bbox.map(v => v / count);

            return { class: className, ...avgDetection };
        }

        async function detectObjects() {
            const detections = await model.detect(video);
            updateDetectionHistory(detections);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            Object.keys(detectionHistory).forEach(className => {
                const smoothedDetection = getSmoothedDetection(className);
                if (smoothedDetection) {
                    drawDetection(smoothedDetection);
                }
            });

            requestAnimationFrame(detectObjects);
        }

        function drawDetection(detection) {
            const [x, y, width, height] = detection.bbox;
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);

            ctx.fillStyle = 'green';
            ctx.font = '16px Arial';
            ctx.fillText(
                `${detection.class} (${Math.round(detection.score * 100)}%)`,
                x,
                y > 10 ? y - 5 : 10
            );
        }

        async function start() {
            await setupCamera();
            await loadModel();
            detectObjects();
        }

        start();
    </script>
</body>
</html>
